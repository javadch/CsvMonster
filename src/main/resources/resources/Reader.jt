@import com.vaiona.csv.reader.*
@import com.vaiona.commons.data.*
@args() {
    String namespace,
    String BaseClassName,
    String Where,
    String rowHeader,
    String linePattern,
    Map<AttributeInfo, String> Ordering,
    Integer skip,
    Integer take,
    boolean writeResultsToFile
}

package @(namespace);

import @(namespace).*;
import com.vaiona.commons.data.*;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.logging.Level;
import java.util.logging.Logger;

public class @(BaseClassName)Reader implements DataReader<@(BaseClassName)Entity> {
    BufferedReader reader;
    BufferedWriter writer;

    //Map<String, FieldInfo> headers = new LinkedHashMap<>();

    String  columnDelimiter     = ",";
    String  quoteMarker       = "\"";
    String  typeDelimiter       = ":";
    String  unitDelimiter       = "::";
    String  commentIndicator    = "#";
    String  missingValue        = "NA";
    String  source              = "";
    String  target              = "";
    boolean bypassFirstRow      = false;
    boolean trimTokens          = true;
    LineParser lineParser       = new DefaultLineParser();

    public List<@(BaseClassName)Entity> read()  throws FileNotFoundException, IOException {
        reader = new BufferedReader(new FileReader(source));

        @if(Ordering!= null && Ordering.size() > 0) {
        Comparator<@(BaseClassName)Entity> sorter = new Comparator<@(BaseClassName)Entity>() {
                    @@Override
                    public int compare(@(BaseClassName)Entity left, @(BaseClassName)Entity right){
                    @for (Map.Entry<AttributeInfo, String> entry : Ordering.entrySet()) {
                        @{
                            DataTypeInfo dti = TypeSystem.getTypes().get(entry.getKey().formalDataType);
                            AttributeInfo ad = entry.getKey();
                        }
                        @if(Ordering.size() == 1) {                            
                            @if(entry.getValue().toUpperCase().equals("ASC")){
                                return @(dti.getComparePattern().replace("$first$", "left." + (ad.name)).replace("$second$", "right." + (ad.name)));
                            } else if(entry.getValue().toUpperCase().equals("DESC")) {
                                return @(dti.getComparePattern().replace("$first$", "right." + (ad.name)).replace("$second$", "left." + (ad.name)));
                            }
                        } else {
                            @if(entry_isFirst){
                                if(@(dti.getComparePattern().replace("$first$", "left." + (ad.name)).replace("$second$", "right." + (ad.name))) != 0){
                                    @if(entry.getValue().toUpperCase().equals("ASC")){
                                        return @(dti.getComparePattern().replace("$first$", "left." + (ad.name)).replace("$second$", "right." + (ad.name)));
                                    } else if(entry.getValue().toUpperCase().equals("DESC")) {
                                        return @(dti.getComparePattern().replace("$first$", "right." + (ad.name)).replace("$second$", "left." + (ad.name)));
                                    }
                                }
                            } else if (!entry_isFirst && !entry_isLast) { 
                                else if(@(dti.getComparePattern().replace("$first$", "left." + (ad.name)).replace("$second$", "right." + (ad.name))) != 0){
                                    @if(entry.getValue().toUpperCase().equals("ASC")){
                                        return @(dti.getComparePattern().replace("$first$", "left." + (ad.name)).replace("$second$", "right." + (ad.name)));
                                    } else if(entry.getValue().toUpperCase().equals("DESC")) {
                                        return @(dti.getComparePattern().replace("$first$", "right." + (ad.name)).replace("$second$", "left." + (ad.name)));
                                    }
                                }
                            } else if (entry_isLast) {
                                else {
                                    @if(entry.getValue().toUpperCase().equals("ASC")){
                                        return @(dti.getComparePattern().replace("$first$", "left." + (ad.name)).replace("$second$", "right." + (ad.name)));
                                    } else if(entry.getValue().toUpperCase().equals("DESC")) {
                                        return @(dti.getComparePattern().replace("$first$", "right." + (ad.name)).replace("$second$", "left." + (ad.name)));
                                    }
                                }
                            }
                        }
                    }
               }
              };
        }

        if(this.bypassFirstRow){
                reader.readLine();
        }           
        lineParser.setQuoteMarker(quoteMarker);
        lineParser.setDilimiter(columnDelimiter);
        lineParser.setTrimTokens(trimTokens);

        @if(!writeResultsToFile){
            List<@(BaseClassName)Entity> result = 
        }
            reader.lines()
                .filter(p -> !p.trim().startsWith(commentIndicator))
                .map(p -> lineParser.split(p))
                .map(p -> new @(BaseClassName)Entity(p))
                @if(Where!= null && !Where.isEmpty()) {
                    .filter(p -> (p.isValid == true) && (@Where))
                }
                else{
                    .filter(p -> (p.isValid == true) )
                }
                @//.parallel()
		@if(Ordering!= null && Ordering.size() > 0) { // if order is present, populate and then sort
                    .map(p->p.populate())
                    .filter(p->p.isValid)
                    .sorted(sorter)
                } else { // if there no ordering, there no need for early post-population, its better to skip/ take and then post-populate
                    @if(skip > -1){
                        .skip(@(skip))
                    }
                    @if(take > -1){
                        .limit(@(take))
                    }
                    .map(p->p.populate())
                    .filter(p->p.isValid)                
                }
                @if(writeResultsToFile){
                    .peek(p-> writeToFile(p))
                    .count() // it is just to make the stream to be consumed
                } else {
                    .collect(Collectors.toList())
                }
                ;
        @if(writeResultsToFile){
            if (writer != null){
               try {
                   writer.flush();
                   writer.close();
               } catch (IOException ex) {
                   Logger.getLogger(TestReader.class.getName()).log(Level.SEVERE, null, ex);
               }        
            }
            return null;
        } else {return result;}
        
    }

    private void writeToFile(@(BaseClassName)Entity entity){
        try {
            if (writer == null) {
                writer = new BufferedWriter(new FileWriter(target));
                writer.write("@rowHeader" + "\n");
            }
            String line = lineParser.join(@linePattern);
            writer.write(line + "\n");
        } catch (IOException ex) {
            Logger.getLogger(TestReader.class.getName()).log(Level.SEVERE, null, ex); // change it with an AdpaterExcetion
        } 
    }

    @@Override
    public DataReader<@(BaseClassName)Entity> columnDelimiter(String value) {
        columnDelimiter = value;
        return this;
    }

    @@Override
    public DataReader<@(BaseClassName)Entity> quoteMarker(String value) {
        quoteMarker = value;
        return this;
    }

    @@Override
    public DataReader<@(BaseClassName)Entity> trimTokens(boolean value) {
        trimTokens = value;
        return this;
    }

    @@Override
    public DataReader<@(BaseClassName)Entity> typeDelimiter(String value) {
        typeDelimiter = value;
        return this;
    }

    @@Override
    public DataReader<@(BaseClassName)Entity> unitDelimiter(String value) {
        unitDelimiter = value;
        return this;
    }

    @@Override
    public DataReader<@(BaseClassName)Entity> missingValue(String value) {
        missingValue = value;
        return this;
    }
    
    @@Override
    public DataReader<@(BaseClassName)Entity> source(String value){
        source = value;
        return this;
    }
    
    @@Override
    public DataReader<@(BaseClassName)Entity> target(String value){
        target = value;
        return this;
    }

    @@Override
    public DataReader<@(BaseClassName)Entity> bypassFirstRow(Boolean value){
         bypassFirstRow = value;
        return this;
    }

    @@Override
    public DataReader<@(BaseClassName)Entity> lineParser(LineParser value){
         lineParser = value;
        return this;
    }
}
